# 동작 파라미터화

- 메서드 내부적으로 **다양한 동작을 수행할 수 있도록** 메서드 인수로 전달
- **변화하는 요구사항에 더 잘 대응할 수 있는 코드 구현** 가능하며, 엔지니어링 비용 절감 가능
- 동작을 메서드의 인수로 전달 가능
  - 인터페이스를 상속받아 여러 클래스를 구현해야하는 수고를 줄일 수 있는 방법 제공

- 코드 블록에 따라 메서드의 동작이 파라미터화 된다.

  - 리스트의 모든 요소에 대해서 '어떤 동작'을 수행할 수 있음

  - 리스트 관련 작업을 끝낸 다음에 '어떤 다른 동작'을 수행할 수 있음

  - 에러가 발생하면 '정해진 어떤 다른 동작'을 수행할 수 있음

- 동작을 캡슐화한 후 -> 메서드로 전달 -> 메서드의 동작을 파라미터화

---

## 2.1 변화하는 요구사항에 대응하기

### 2.1.1 첫 번째 시도 : 녹색 사과 필터링

```java
enum Color {RED, GREEN}

public static List<Apple> filterGreenApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<>();         // 사과 누적 리스트
        for (Apple apple : inventory) {
            if (GREEN.equals(apple.getColor())) {       // 녹색 사과만 선택
                result.add(apple);
            }
        }
        return result;
    }
```



- 현재 요구사항 : 녹색 사과 필터링

  - 추가 요구사항 : 빨간 사과 등 좀 더 다양한 색으로 필터링

    > 색을 파라미터화 해서 해결



### 2.1.2 두 번째 시도 : 색을 파라미터화

```java
public static List<Apple> filterApplesByColor(List<Apple> inventory, Color color) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (apple.getColor().equals(color)) {
                result.add(apple);
            }
        }
        return result;
    }
```



- 현재 요구사항 : 색으로 사과 필터링
  - 추가 요구사항 : 다양한 무게에 대응할 수 있도록 무게 정보 필터링



### 2.1.3 세 번째 시도 : 가능한 모든 속성으로 필터링

```java
public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (apple.getWeight() > weight) {
                result.add(apple);
            }
        }
        return result;
    }
```



모든 속성을 메서드 파라미터로 추가한 시도까지 해본 결과 앞으로 요구사항이 바뀌었을 때 유연하게 대응이 불가능하다.

> 사과의 크기, 모양, 출하지 등으로 필터링하고 싶을 경우엔?
>
> 녹색 사과 중 무거운 사과를 필터링하고 싶은 경우엔?

결국 여러 중복된 필터 메서드를 만들거나 모든 것을 처리하는 거대한 하나의 필터 메서드를 구현해야 한다.



이러한 경우로 인해 동작 파라미터화를 이용해서 유연성을 얻어야 한다.



## 2.2 동작 파라미터화

사과의 어떤 속성에 기초해서 불리언값을 반환하는 방법이 있다.

참 또는 거짓을 반환하는 함수를 프레디케이트(Predicate) 라고 한다.

```java
// 선택 조건을 결정하는 인터페이스
public interface ApplePredicate {
    boolean test(Apple apple);
}

// 여러 버전의 ApplePredicate 정의
public class AppleHeavyWeightPredicate implements ApplePredicate{

    @Override
    public boolean test(Apple apple) {
        return apple.getWeight() > 150;
    }
}

public class AppleGreenColorPredicate implements ApplePredicate{

    @Override
    public boolean test(Apple apple) {
        return GREEN.equals(apple.getColor());
    }
}

```



이렇게 filterApples 에서 ApplePredicate 객체를 받아와 사과의 조건을 검사하도록 메서드를 고쳐야 한다.

동작 파라미터화 = 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작을 수행 가능



### 2.2.1 네 번째 시도 : 추상적 조건으로 필터링

```java
public static List<Apple> filter(List<Apple> inventory, ApplePredicate predicate) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (predicate.test(apple)) {
                result.add(apple);
            }
        }
        return result;
    }

public class AppleRedAndHeavyPredicate implements ApplePredicate{
    @Override
    public boolean test(Apple apple) {
        return RED.equals(apple.getColor()) && apple.getWeight() > 150;
    }
}

List<Apple> redAndHeavyApples = filter(inventory, new AppleRedAndHeavyPredicate());
        System.out.println("redAndHeavyApples = " + redAndHeavyApples);
```




![parameter](./src/img/parameter.PNG)
> filterApples의 동작을 파라미터화하고 다양한 필터 전달하기

![parameter2](./src/img/parameter2.PNG)

> filterApples의 동작을 파라미터화하고 다양한 필터 전략 전달



## 2.3 복잡한 과정 간소화 - 익명클래스

익명클래스

- 자바의 지역 클래스 (블록 내부에 선언된 클래스)와 비슷한 개념
- 이름이 없는 클래스

- 클래스의 선언과 인스턴스화를 동시에 수행 -> 즉석에서 필요한 구현을 만들어서 사용 가능



### 2.3.2 다섯 번째 시도 : 익명 클래스 사용

```java
List<Apple> redApples = filter(inventory, new ApplePredicate() {    // filterApples 메서드의 동작을 직접 파라미터화
@Override
public boolean test(Apple apple) {
        return RED.equals(apple.getColor());
        }
        });
```

> 익명 클래스의 부족한 점
>
> - 많은 공간을 차지
> - 익명 클래스의 사용에 익숙하지 않음
> - 코드 조각을 전달하는 과정에서 결국은 객체를 만들고 명시적으로 새로운 동작을 정의하는 메서드를 구현해야 한다는 점



#### 동작 파라미터화를 이용하면 요구사항 변화에 더 유연하게 대응할 수 있으므로 권장.



### 2.3.3 여섯 번째 시도 : 람다 표현식 사용

```java
List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```



### 2.3.4 일곱 번째 시도 : 리스트 형식으로 추상화

```java
public interface Predicate<T> {
  boolean test(T t);
}

  public static <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> result = new ArrayList<>();
    for (T e : list) {
      if (p.test(e)) {
        result.add(e);
      }
    }
    return result;
  }

  // 일곱 번째 시도
  List<Apple> redApples7 = filter(inventory, (Apple apple) -> RED.equals(apple.getColor()));
System.out.println("redApples7 = " + redApples7);

```

